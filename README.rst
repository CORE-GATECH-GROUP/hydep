hydep
=====

A hybrid depletion framework for reactor physics applications and
analysis. 

.. image:: https://zenodo.org/badge/DOI/10.1016/j.anucene.2020.108120.svg
   :target: https://doi.org/10.1016/j.anucene.2020.108120
   :alt: Annals of Nuclear Energy 10.1016/j.anucene.2020.108120

Motivation
----------

When modeling a nuclear application such as a commercial power reactor,
one often wants to know

1. How quickly is the fuel being consumed? Burnable absorbers?
2. How long will the reactor remain operational? Or maintain criticality?
3. How do the power distribution, temperature profiles, and other fields
   change with time?
4. When we refuel, how do we best mitigate the heat generated by decay of
   spent fuel?

These are questions that can be understood with a depletion simulation.
The typical approach is to perform some coupling between neutron
transport and depletion solvers. The former is responsible for obtaining
the power distribution and rates of isotopic transmutation, while the later
updates compositions across a discrete time step. Improved methods perform
additional transport solutions to better model and weight these reaction rates.

There unfortunately exists a difficult trade-off between decreasing the
size of the depletion step and the total simulation time. If we wanted
to model an 18 month fuel cycle with very fine temporal resolution, we
might choose to use depletion steps of a single day. This means we would
need to perform hundreds of transport solutions. Depending on the fidelity
of our transport solver (e.g. Monte Carlo with no approximations to
geometry or particle energy) and complexity of our model (e.g. 3-D reactor
model), it may take a prohibitively large simulation time to finish the
simulation. Conversely, we can increase the depletion step from one day
to several days to months.  Meaning our simulation will complete faster,
but with (potentially much) larger differences in reactivity (i.e.
predicted operational time), predictions of isotopic inventory, power
distributions, and other quantities of interest.

This library provides a framework for implementing a hybrid depletion
scheme, where a faster reduced-order simulation is performed at
sub-depletion steps between more expensive high-fidelity solutions. These
substeps allow the isotopics and their reaction rates to be captured with
a fine temporal resolution without the computational burden of many
high-fidelity transport solutions. Using this library and the provided
interfaces, one (in theory) could link a Monte Carlo code with a
nodal diffusion code as the high-fidelity and reduced-order solvers.
Since the library includes a dedicated depletion backend, inspired heavily
from `OpenMC <https://github.com/openmc-dev/openmc>`_ [OpenMC_dep]_,
neither solver is required to have an integrated depletion solver.
At this time however, only two concrete interfaces are provided,
for the Serpent [Serpent]_ Monte Carlo code and the SFV prediction
method [SFV]_.

Installation
------------

The recommended approach is to install using a virtual environment.
From the command line, execute the command

.. code-block:: shell

    $ python -m venv /path/to/venv
    $ source /path/to/venv/bin/activate

The dependencies and package can then be installed with

.. code-block:: shell

    (venv) $ pip install .

The framework was designed to be a general and extensible tool, with
abstract interfaces for general transport codes. With this base
installation, one obtains the necessary classes to design concrete
interfaces, but no real useful interfaces. These are instead delegated
to extra packages

Serpent interface
~~~~~~~~~~~~~~~~~

The primary neutronics interface here is for the Serpent Monte Carlo
code [Serpent]_. The necessary dependencies can be installed with

.. code-block:: shell

    (venv) $ pip install .[serpent]

The ``hydep`` interfaces to Serpent will still be installed without this
command, but attempting to import from ``hydep.serpent`` will likely fail.

Two interfaces as presented, one for the current Serpent version and another
for an extended version of Serpent yet to be distributed. This later version
allows the framework to pass updated compositions to Serpent via a data file
without Serpent reloading the model and cross sections at each depletion step.
Discussion are being had regarding the best way to distribute these changes.
In the meantime, the ``SerpentSolver`` can be used to perform hybrid
transport-depletion simulations, but with some waiting and restarting.

SFV interface
~~~~~~~~~~~~~

The primary reduced-order solver developed for this work is to the
spatial flux variation (SFV) method [SFV]_. This requires a small
FORTRAN library wrapped in a Python package. The source code for this
package is available at `CORE-GATECH-GROUP/sfv
<https://github.com/CORE-GATECH-GROUP/sfv>`_. Users can follow
`its installation instructions <https://github.com/CORE-GATECH-GROUP/sfv#installation>`_
or run the command

.. code-block:: shell

    (venv) $ pip install .[sfv]

.. note::

    Please be familiar with some of the issues uninstalling and upgrading
    this package, `presented here
    <https://github.com/CORE-GATECH-GROUP/sfv#upgrading--uninstalling>`_


Kitchen sink
~~~~~~~~~~~~

To install all dependencies for the base package, the Serpent interface, and
the SFV interface, the command

.. code-block:: shell

    (venv) $ pip install .[serpent,sfv]

Testing
-------

Tests require ``pytest`` which can be pulled from the ``test`` extras package

.. code-block:: shell

    (venv) $ pip install .[test]

To run all tests, run 

.. code-block:: shell

   (venv) $ ./runtests

This script is admittedly a crutch around some flaky design, where generated
Serpent cards must *exactly* match reference snippets. The downside to this is
related to an internal material registry that is not cleared if an earlier test
fails. Meaning some tests that *should* pass don't because of an off material or
cell index

.. code-block:: diff

    --- steady_state_reference
    +++ steady_state_fail
    @@ -6,7 +6,7 @@
      */
     include "BASEFILE"
     set power 1.0000000E+04
    -mat 1 -10.3400000 burn 1
    +mat 18 -10.3400000 burn 1
     8016.09c 4.602600000E-02
     8017.09c 1.753300000E-05
     92234.09c 5.995900000E-06

Tests can be isolated using ``pytest`` marks. Parts of the library that relate to
specific interfaces can be excluded or isolated using the ``-m`` switch. The following
will run just tests related to the SFV interface

.. code-block:: shell

    (venv) $ pytest -m sfv

The current test layout does not well support testing just the base library with

.. code-block:: shell

    (venv) $ pytest -m "not serpent" -m "not sfv"

unless **both** the Serpent and SFV extras have been installed. Also, the Serpent
tests include a test with the coupled solver, which is not yet excluded with
a dedicated mark.


Documentation
-------------

Documentation is built using ``sphinx`` and currently is not hosted
online. It can be built locally by following these steps.

.. code-block:: shell

    (venv) $ pip install .[docs]
    (venv) $ cd docs
    (venv) $ make html

This will produce documentation that can be viewed locally by opening
``docs/_build/html/index.html``. The command ``make latexpdf`` will produce
``docs/_build/latex/hydep.pdf``.
There are two examples in ``docs/examples`` presented as jupyter notebooks that
build and simulate a 3-D pincell and then process the results.

Caveats / Warnings
------------------

This is a **highly experimental and developmental** library / tool.
While a modest set of cases are covered by tests and examples, there
are likely cases that are missed and could cause bugs. Please report
these and be forgiving.

This framework does not seek to be a general geometric modeling tool
for nuclear analysis, nor even a really good one. Some limits are
self imposed or assumed to move from developing geometry to
implementing the physics. First, the framework is primarily focused on
modeling Cartesian assemblies with annular fuel. This is sufficient for
most light water reactor analysis, as fuel pins are basically
concentric cylinders of materials, and these assemblies are regular
Cartesian lattices.

Second, many of the input files generated for transport solutions
should not be considered human readable. Some aesthetic considerations
have been taken, but universe names and identifiers may be hard to
understand. 

See ``./docs/scope.rst`` for more description on the scope and limits of
this project.

Citing
------

.. code-block:: bibtex

    @article{JOHNSON2021108120,
        author = {Andrew Johnson and Dan Kotlyar},
        doi = {https://doi.org/10.1016/j.anucene.2020.108120},
        issn = {0306-4549},
        journal = {Annals of Nuclear Energy},
        keywords = {Monte Carlo, Depletion, Stability, Fission matrix, Perturbation theory},
        pages = {108120},
        title = {Hybrid depletion framework using mixed-fidelity transport solutions and substeps},
        url = {https://www.sciencedirect.com/science/article/pii/S0306454920308161},
        volume = {155},
        year = {2021},
    }

References
----------

.. [OpenMC_dep] Romano et al. "Depletion capabilities in the OpenMC
   Monte Carlo particle transport code." Ann. Nuc. Ene. `152 (2021) 107989
   <https://doi.org/10.1016/j.anucene.2020.107989>`_

.. [Serpent] Leppanen, J. et al. "The Serpent Monte Carlo code: Status,
    development and applications in 2013." Ann. Nucl. Ene, `82 (2015) 142-150
    <http://www.sciencedirect.com/science/article/pii/S0306454914004095>`_

.. [SFV] Johnson, A. and Kotlyar, D. "A Transport-Free Method for Predicting
   the Post-depletion Spatial Neutron Flux." Nuc. Sci. Eng, `194 (2020) 120-137
   <https://doi.org/10.1080/00295639.2019.1661171>`_
